"use strict";

import log from "./log";
import fs from "fs";
import net from "net";
import colors from "chalk";
import Helper from "./helper";
import Config from "./config";

class Identification {
	private connectionId: number;
	private connections: Map<any, any>;
	private oidentdFile: string;

	constructor(startedCallback: Function) {
		this.connectionId = 0;
		this.connections = new Map();

		if (typeof Config.values.oidentd === "string") {
			this.oidentdFile = Helper.expandHome(Config.values.oidentd);
			log.info(`Oidentd file: ${colors.green(this.oidentdFile)}`);

			this.refresh();
		}

		if (Config.values.identd.enable) {
			if (this.oidentdFile) {
				log.warn(
					"Using both identd and oidentd at the same time, this is most likely not intended."
				);
			}

			const server = net.createServer(this.serverConnection.bind(this));

			server.on("error", (err) => {
				startedCallback(this, err);
			});

			server.listen(
				{
					port: Config.values.identd.port || 113,
					host: Config.values.bind,
				},
				() => {
					const address = server.address();
					if (typeof address === "string") {
						log.info(`Identd server available on ${colors.green(address)}`);
					} else if (address.address) {
						log.info(
							`Identd server available on ${colors.green(
								address.address + ":" + address.port
							)}`
						);
					}

					startedCallback(this);
				}
			);
		} else {
			startedCallback(this);
		}
	}

	serverConnection(socket) {
		socket.on("error", (err) => log.error(`Identd socket error: ${err}`));
		socket.on("data", (data) => {
			this.respondToIdent(socket, data);
			socket.end();
		});
	}

	respondToIdent(socket, data) {
		data = data.toString().split(",");

		const lport = parseInt(data[0], 10) || 0;
		const fport = parseInt(data[1], 10) || 0;

		if (lport < 1 || fport < 1 || lport > 65535 || fport > 65535) {
			return;
		}

		for (const connection of this.connections.values()) {
			if (connection.socket.remotePort === fport && connection.socket.localPort === lport) {
				return socket.write(
					`${lport}, ${fport} : USERID : TheLounge : ${connection.user}\r\n`
				);
			}
		}

		socket.write(`${lport}, ${fport} : ERROR : NO-USER\r\n`);
	}

	addSocket(socket, user) {
		const id = ++this.connectionId;

		this.connections.set(id, {socket, user});

		if (this.oidentdFile) {
			this.refresh();
		}

		return id;
	}

	removeSocket(id) {
		this.connections.delete(id);

		if (this.oidentdFile) {
			this.refresh();
		}
	}

	refresh() {
		let file = "# Warning: file generated by The Lounge: changes will be overwritten!\n";

		this.connections.forEach((connection) => {
			file +=
				`fport ${connection.socket.remotePort}` +
				` lport ${connection.socket.localPort}` +
				` { reply "${connection.user}" }\n`;
		});

		fs.writeFile(this.oidentdFile, file, {flag: "w+"}, function (err) {
			if (err) {
				log.error("Failed to update oidentd file!", err);
			}
		});
	}
}

export default Identification;
